'''Логический''' (булев) тип данных — примитивный  в , которые могут принимать два возможных значения, иногда называемых ''правдой'' и ''ложью''. Присутствует в подавляющем большинстве языков программирования как самостоятельная сущность или реализуется через численный тип. В подавляющем большинстве языков за истину полагается единица, за ложь - ноль.
Булевый тип данных может быть реализован с использованием только одного а, но обычно используется минимальная адресуемая ячейка памяти () или , как эффективная единица работы с регистрами и оперативной памятью.
К этому типу данных применимы следующие операции:
Так же могут использоваться и другие операции . Большинство языков программирования позволяют использовать булевый тип и в арифметических операциях, приводя его к численному типу согласно принятым в языке правилам приведения типов.
Традиционным применением булевого типа данных являются значения «да»/«нет» в отношении результата более сложных операций.
Все операции сравнения  двух величин (равно, больше, меньше), операции вхождения элемента в множество и проверка на пересечение множеств возвращают в качестве результата булевый тип.
 определяет <code>Boolean</code> в пакете Standard как нумерованный тип со значениями <code>False</code> и <code>True</code> в котором <code>False</code> < <code>True</code>.
 type Boolean is (False, True);
 p : Boolean := True;
 ...
 if p then
   ...
 end if;
Родственные операторы (<code>=</code>, <code>/=</code>, <code><</code>, <code><=</code>, <code>></code>, <code>>=</code>) применяются ко всем нумерованым типам, включая <code>Boolean</code>.  Булевые операторы <code>and</code>, <code>or</code>, <code>xor</code> и <code>not</code> применимы к типу <code>Boolean</code> и любым объявленным подтипам.  Булевые операторы также применимы к массивам, содержащим значения <code>Boolean</code>.
 имеет тип данных <code>boolean</code> и соответствующие операторы, установленные в спецификации Algol 60.  Тип данных был сокращён до <code>bool</code> в .
В , который не предоставлял булевых значений в  (но вводит в ) вместо значений true/false было установлено сравнение значения с нулём. Для примера, код на C
 if (my_variable) {
   printf("True!\n");
 } else {
   printf("False!\n");
 }
равнозначен коду
 if (my_variable != 0) {
   printf("True!\n");
 } else {
   printf("False!\n");
 }
Это было честно для типа данных  (integer); тем не менее бинарные значения  (floating-point) были приближёнными к выводимым на экран десятичным значениям и это давало ошибки при сравнении. Традиционно, целое содержало одну (или более) булевую переменную (одну на каждый  целого).
В  логический тип обозначается служебным словом КЛЮЧ (от «ключевой»). Возможны два значения: <code>ВКЛ</code> и <code>ОТКЛ</code>, являющиеся встроенными в язык . Занимает в  8 двоичных  (ячейку), что сделано для наиболее быстрого доступа к данным этого вида.
Предусмотрены следующие логические действия:
Эти действия применимы только к данным вида КЛЮЧ и дают ответ вида КЛЮЧ. Также, все отношения в Глаголе дают ответ логического типа.
Пример объявления и использования:
  ПЕР
    работаем: КЛЮЧ;
  УКАЗ
    ЕСЛИ работаем ТО
      Выполнить();
      работаем := ОТКЛ
    КОН
В языке  булевый тип данных обозначается как <code>bool</code>, для приведения других типов данных к булеву существует функция <code>bool()</code>, работающая по следующим соглашениям:
Для других объектов результат рассчитывается через метод __nonzero__, который в идеале должен возвращать значения True/False.
Булевый тип приводится к следующим типам данных:
К другим типам данных булевый тип не приводится.
В  булевский тип представлен двумя предопределенными : <code>true</code> и <code>false</code>. Появляется логический тип в результате логических операций или вызова логических ов. По традиции, имя логических методов (то есть методов, которые возвращают значение true или false) заканчивается на «?».
В качестве <code>false</code> может выступать <code>nil</code>, а в качестве <code>true</code> — любой , в том числе  со значением «0» или пустая , что часто является неожиданностью для новичков.